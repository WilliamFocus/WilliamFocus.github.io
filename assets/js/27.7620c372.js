(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{604:function(_,t,v){"use strict";v.r(t);var s=v(4),r=Object(s.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[v("strong",[_._v("类")]),_._v("实际上完全是"),v("strong",[_._v("构造函数")]),_._v("的另一种写法而已。（创建构造函数+设置原型对象）")]),_._v(" "),v("p",[v("em",[_._v("类的核心其实还是 constructor，只不过是合并设置 prototype 的写法(语法糖，类也可以看作原型对象)")])]),_._v(" "),v("h2",{attrs:{id:"_1-类的基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-类的基础"}},[_._v("#")]),_._v(" 1.类的基础")]),_._v(" "),v("ul",[v("li",[_._v("Class 中的所有函数都是定义在原型上的，包括 constructor(),......，且都是不可枚举的，而 ES5 的写法是可以枚举的；")]),_._v(" "),v("li",[_._v("new 类时实质是调用一次 constructor 方法；")]),_._v(" "),v("li",[_._v("类中可以定义函数，不需要加关键字，函数将成为原型上的方法；\n也可以定义变量，将成为实例上的属性；(实质是构造函数内声明的另一种写法，实例属性新写法)\n（"),v("em",[_._v("注：函数也可以用表达式写法~，public class fields 语法")]),_._v("）")]),_._v(" "),v("li",[_._v("使用了"),v("strong",[_._v("babel")]),_._v("的和"),v("strong",[_._v("class")]),_._v("中的方法都默认开启严格模式，函数中 this 指向全局时(单独使用)为 undefined；")]),_._v(" "),v("li",[_._v("类中的方法 this 指向实例，但如果被当作事件回调传递，当再次调用时则 this 将成为 undefined，可使用**.bind(this)"),v("strong",[_._v("或者")]),_._v("箭头函数**解决；(还可以使用 Proxy)")]),_._v(" "),v("li",[_._v("类不存在变量提升，且跟普通函数一样具有默认 name=''自身''的属性；")]),_._v(" "),v("li",[_._v("static 关键字：\n"),v("ul",[v("li",[_._v("定义类的静态属性/方法，不会被实例继承，而是直接由类调用；")]),_._v(" "),v("li",[_._v("且该方法 this 指向类自身；")]),_._v(" "),v("li",[_._v("可与非静态(实例定义在 protoType 上的)方法同名；")]),_._v(" "),v("li",[_._v("可以被子类继承")])])]),_._v(" "),v("li",[_._v("私有属性和方法可以使用#命名方式表示；")]),_._v(" "),v("li",[v("code",[_._v("new.target")]),_._v("在构造函数中使用表示当前触发调用的类，且必须是使用 new 或 Reflect.construct()调用，否则值为 undefined；")]),_._v(" "),v("li",[_._v("类也可以写成表达式；或者类内部的方法名也可以写成表达式；")])]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_2-类的继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-类的继承"}},[_._v("#")]),_._v(" 2.类的继承")]),_._v(" "),v("p",[_._v("（其实可以看是原型对象的继承）")]),_._v(" "),v("ul",[v("li",[_._v("子类在使用 extends 关键字继承后会通过 prototype(即指父类)中查找方法；")]),_._v(" "),v("li",[_._v("extends 关键字后面可以跟任意类或者函数，可以用来完美继承原生构造函数；")]),_._v(" "),v("li",[_._v("super 指向父类的原型对象，静态方法中代表父类；而 super()代表调用父类构造函数；")]),_._v(" "),v("li",[_._v("使用 super()时会调用父类构造函数且其中的 this 指向当前子类的实例；\n(相当于 A.prototype.constructor.call(this))")]),_._v(" "),v("li",[_._v("子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例\n所以 super 在子类中使用时可直接看成 this；")]),_._v(" "),v("li",[_._v("子类在继承时若显示定义了 constructor()则"),v("strong",[_._v("规定必须")]),_._v("在内**先写 super()**用于继承父类的实例属性；\n"),v("strong",[_._v("原因：")]),_._v(" 1. 这是因为子类实例的构建，基于父类实例； 2. super()用于调用一下父类构造函数来塑造一个对象，子类才能得到 this 对象，同时得到同样的实例属性和方法再进行加工；")])]),_._v(" "),v("hr"),_._v(" "),v("p",[v("strong",[_._v("💡 类的继承是按照下面的模式实现的：")])]),_._v(" "),v("p",[_._v("这两条继承链，可以这样理解：")]),_._v(" "),v("ul",[v("li",[_._v("作为一个对象，子类（B）的原型（"),v("strong",[_._v("proto")]),_._v("属性）是父类（A）；")]),_._v(" "),v("li",[_._v("作为一个构造函数，子类（B）的原型对象（prototype 属性）是父类的原型对象（prototype 属性）的实例。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);